use anchor_lang::prelude::*;
use anchor_lang::{AnchorSerialize, AnchorDeserialize};

// #[program]
// pub mod ray {
//     use super::*;
//     pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {
//         Ok(())
//     }

//     pub fn provide_lp(ctx: Context<ProvideLp>) -> ProgramResult {
//         Ok(())
//     }
// }

// #[derive(Accounts)]
// pub struct Initialize {}

// #[derive(Accounts)]
// pub struct ProvideLp<'info> {
//     /// Provide LP:
//     ///
//     /// 0. `[writable]` token program id
//     /// 1. `[writable]` amm id
//     /// 2. `[writable]` amm authority
//     /// 3. `[writable]` amm open orders
//     /// 4. `[writable]` amm target orders
//     /// 5. `[writable]` lp mint address
//     /// 6. `[writable]` pool coin token account
//     /// 7. `[writable]` pool pc token account
//     /// 8. `[writable]` user coin token account
//     /// 9. `[writable]` user pc token account
//     /// 10.`[writable]` user lp token account
//     /// 11.`[signer]` user owner 
//     /// 
//     #[account(mut)]
//     token_program: AccountInfo<'info>,
//     #[account(mut)]
//     amm_program: AccountInfo<'info>,
//     #[account(mut)]
//     amm_authority: AccountInfo<'info>,
//     #[account(mut)]
//     amm_target_orders: AccountInfo<'info>,
//     #[account(mut)]
//     lp_mint_address: AccountInfo<'info>,
//     #[account(mut)]
//     pool_coin_token_account: AccountInfo<'info>,
//     #[account(mut)]
//     pool_pc_token_account: AccountInfo<'info>,
//     #[account(mut)]
//     user_coin_token_account: AccountInfo<'info>,
//     #[account(mut)]
//     user_pc_token_account: AccountInfo<'info>,
//     #[account(mut)]
//     user_lp_token_account: AccountInfo<'info>,
//     #[account(mut, signer)]
//     owner: AccountInfo<'info>,
// }

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct ProvideLpPayload{
    instruction: u8,
    max_coin_amount: u64, 
    max_pc_amount: u64, 
    fixed_from_coin: u64,
}

#[interface]
pub trait Provide<'info, T: Accounts<'info>> {
    fn provide_lp(ctx: Context<T>, payload: ProvideLpPayload) -> ProgramResult;
}

#[program]
pub mod ray {
    use super::*;


    pub fn provide_lp(
        ctx: Context<ProvideLpAccounts>, 
        instruction: u8,
        max_coin_amount: u64, 
        max_pc_amount: u64, 
        fixed_from_coin: u64,
    ) -> ProgramResult { 
        let cpi_program = ctx.accounts.ray_program.clone();
        let cpi_ctx = CpiContext::new(cpi_program, RayProvideLP{
            token_program: ctx.accounts.token_program.clone(),
            amm_program: ctx.accounts.amm_program.clone(),
            amm_authority: ctx.accounts.amm_authority.clone(),
            amm_open_orders: ctx.accounts.amm_open_orders.clone(),
            amm_target_orders: ctx.accounts.amm_target_orders.clone(),
            lp_mint_address: ctx.accounts.lp_mint_address.clone(),
            pool_coin_token_account: ctx.accounts.pool_coin_token_account.clone(),
            pool_pc_token_account: ctx.accounts.pool_pc_token_account.clone(),
            serum_market: ctx.accounts.serum_market.clone(),
            user_coin_token_account: ctx.accounts.user_coin_token_account.clone(),
            user_pc_token_account: ctx.accounts.user_pc_token_account.clone(),
            user_lp_token_account: ctx.accounts.user_lp_token_account.clone(),
            owner: ctx.accounts.owner.clone(),
        });
        // This is the client generated by the `#[interface]` attribute.
        provide::provide_lp(cpi_ctx, ProvideLpPayload{
            instruction,
            max_coin_amount, 
            max_pc_amount, 
            fixed_from_coin,
        })?;

        Ok(())
    }


    // pub fn provide_lp() -> ProgramResult {
    //     Ok(())
    // }
    // #[state]
    // pub struct Counter {
    //     pub count: u64,
    //     pub auth_program: Pubkey,
    // }

    // impl Counter {
    //     pub fn new(_ctx: Context<Empty>, auth_program: Pubkey) -> Result<Self> {
    //         Ok(Self {
    //             count: 0,
    //             auth_program,
    //         })
    //     }

    //     pub fn set_count(&mut self, ctx: Context<SetCount>, new_count: u64) -> Result<()> {
    //         // Ask the auth program if we should approve the transaction.
    //         let cpi_program = ctx.accounts.auth_program.clone();
    //         let cpi_ctx = CpiContext::new(cpi_program, Empty {});

    //         // This is the client generated by the `#[interface]` attribute.
    //         auth::is_authorized(cpi_ctx, self.count, new_count)?;

    //         // Approved, so update.
    //         self.count = new_count;
    //         Ok(())
    //     }
    // }
}

#[derive(Accounts)]
pub struct Empty {}

#[derive(Accounts)]
pub struct SetCount<'info> {
    auth_program: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct ProvideLpAccounts<'info> {
    /// Provide LP:
    ///
    /// 0. `[writable]` token program id
    /// 1. `[writable]` amm id
    /// 2. `[writable]` amm authority
    /// 3. `[writable]` amm open orders
    /// 4. `[writable]` amm target orders
    /// 5. `[writable]` lp mint address
    /// 6. `[writable]` pool coin token account
    /// 7. `[writable]` pool pc token account
    /// 8. `[writable]` user coin token account
    /// 9. `[writable]` user pc token account
    /// 10.`[writable]` user lp token account
    /// 11.`[signer]` user owner 
    /// 
    #[account(mut)]
    token_program: AccountInfo<'info>,
    #[account(mut)]
    amm_program: AccountInfo<'info>,
    #[account(mut)]
    amm_authority: AccountInfo<'info>,
    #[account(mut)]
    amm_open_orders: AccountInfo<'info>,
    #[account(mut)]
    amm_target_orders: AccountInfo<'info>,
    #[account(mut)]
    lp_mint_address: AccountInfo<'info>,
    #[account(mut)]
    pool_coin_token_account: AccountInfo<'info>,
    #[account(mut)]
    pool_pc_token_account: AccountInfo<'info>,
    #[account(mut)]
    serum_market: AccountInfo<'info>,
    #[account(mut)]
    user_coin_token_account: AccountInfo<'info>,
    #[account(mut)]
    user_pc_token_account: AccountInfo<'info>,
    #[account(mut)]
    user_lp_token_account: AccountInfo<'info>,
    #[account(mut, signer)]
    owner: AccountInfo<'info>,
    #[account(mut)]
    ray_program: AccountInfo<'info>,
}


#[derive(Accounts)]
pub struct RayProvideLP<'info> {
    #[account(mut)]
    token_program: AccountInfo<'info>,
    #[account(mut)]
    amm_program: AccountInfo<'info>,
    #[account(mut)]
    amm_authority: AccountInfo<'info>,
    #[account(mut)]
    amm_open_orders: AccountInfo<'info>,
    #[account(mut)]
    amm_target_orders: AccountInfo<'info>,
    #[account(mut)]
    lp_mint_address: AccountInfo<'info>,
    #[account(mut)]
    pool_coin_token_account: AccountInfo<'info>,
    #[account(mut)]
    pool_pc_token_account: AccountInfo<'info>,
    #[account(mut)]
    serum_market: AccountInfo<'info>,
    #[account(mut)]
    user_coin_token_account: AccountInfo<'info>,
    #[account(mut)]
    user_pc_token_account: AccountInfo<'info>,
    #[account(mut)]
    user_lp_token_account: AccountInfo<'info>,
    #[account(mut, signer)]
    owner: AccountInfo<'info>,
}


// impl<'info> SetCount<'info> {
//     pub fn accounts(counter: &Counter, ctx: &Context<SetCount>) -> Result<()> {
//         if ctx.accounts.auth_program.key != &counter.auth_program {
//             return Err(ErrorCode::InvalidAuthProgram.into());
//         }
//         Ok(())
//     }
// }

#[error]
pub enum ErrorCode {
    #[msg("Invalid auth program.")]
    InvalidAuthProgram,
}

